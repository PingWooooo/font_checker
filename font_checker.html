<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>網站字體全站分析器 (含內嵌檢測)</title>
    <!-- Tailwind CSS 樣式庫 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- XLSX-JS-STYLE 用於產生帶樣式的 Excel -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <!-- Font Awesome 圖示 -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;600&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; }
        .mono { font-family: 'JetBrains Mono', monospace; }
        
        /* 自訂捲軸樣式 */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* 載入動畫 */
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* 狀態顏色 */
        .scan-status-pending { @apply text-slate-400; }
        .scan-status-loading { @apply text-blue-600 font-bold; }
        .scan-status-done { @apply text-green-600; }
        .scan-status-error { @apply text-red-500; }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 min-h-screen flex flex-col">

    <!-- Header 區塊 -->
    <header class="bg-white border-b border-slate-200 sticky top-0 z-20 shadow-sm">
        <div class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="bg-indigo-600 text-white p-2 rounded-lg">
                    <i class="fa-solid fa-sitemap"></i>
                </div>
                <div>
                    <h1 class="text-xl font-bold text-slate-800">網站字體全站分析器</h1>
                    <div class="text-xs text-slate-500 hidden sm:block">
                        支援外部連結 (External) 與內嵌編碼 (Base64) 識別
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content 主內容 -->
    <main class="flex-grow max-w-6xl mx-auto px-4 py-8 w-full space-y-6">

        <!-- Input Section 輸入區 -->
        <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
            <label class="block text-sm font-medium text-slate-700 mb-2">目標網站網址 (URL)</label>
            <div class="flex flex-col sm:flex-row gap-3">
                <div class="relative flex-grow">
                    <input type="text" id="urlInput" 
                        value="https://www.darwinprecisions.com/zh-tw" 
                        placeholder="請輸入完整網址，例如 https://example.com/zh-cn"
                        class="w-full px-4 py-3 pr-10 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition mono text-sm"
                    >
                    <!-- 清除按鈕 -->
                    <button onclick="clearInput()" class="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-slate-600 p-2 transition" title="清除">
                        <i class="fa-solid fa-circle-xmark"></i>
                    </button>
                </div>
                
                <!-- 開始分析按鈕 -->
                <button onclick="startInitialScan()" id="analyzeBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium px-6 py-3 rounded-lg transition flex items-center justify-center gap-2 min-w-[140px] shadow-md hover:shadow-lg transform active:scale-95">
                    <i class="fa-solid fa-magnifying-glass"></i>
                    <span>開始分析</span>
                </button>
            </div>
            <p class="text-xs text-slate-500 mt-2 flex items-center gap-2">
                <i class="fa-solid fa-shield-halved text-orange-500"></i>
                <span>系統會區分「外部連結」與「內嵌編碼 (Base64)」，後者可能涉及字體再製的授權問題。</span>
            </p>
        </div>

        <!-- 主介面區塊（掃描狀態、結果、統計） -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 hidden" id="mainInterface">
            
            <!-- 左側：掃描隊列與狀態 -->
            <div class="lg:col-span-1 space-y-6">
                <!-- 掃描狀態面板 -->
                <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col h-[500px]">
                    <div class="p-4 border-b border-slate-100 bg-slate-50 flex justify-between items-center">
                        <h3 class="font-bold text-slate-700 text-sm">
                            <i class="fa-solid fa-list-ul mr-1"></i> 掃描隊列
                        </h3>
                        <span id="queueCount" class="text-xs bg-slate-200 text-slate-600 px-2 py-1 rounded-full">0</span>
                    </div>
                    
                    <!-- 批次掃描操作 -->
                    <div id="batchActions" class="p-3 border-b border-slate-100 bg-indigo-50 hidden">
                        <div class="text-xs text-indigo-800 mb-2 font-medium">發現同目錄頁面，是否批次掃描？</div>
                        <button onclick="startBatchScan()" id="batchBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white text-xs py-2 rounded transition flex items-center justify-center gap-2">
                            <i class="fa-solid fa-layer-group"></i> 掃描所有發現頁面
                        </button>
                    </div>

                    <!-- 隊列網址列表 -->
                    <div id="urlList" class="overflow-y-auto flex-grow p-2 space-y-1 text-xs">
                        <!-- URLs injected here -->
                    </div>
                    
                    <!-- Console Log 日誌 -->
                    <div class="h-32 bg-slate-900 text-slate-300 p-3 font-mono text-[10px] overflow-y-auto border-t border-slate-700 shrink-0" id="miniLog">
                        <div>> 系統就緒...</div>
                    </div>
                </div>
            </div>

            <!-- 右側：結果與統計 -->
            <div class="lg:col-span-2 space-y-6">
                
                <!-- 統計數據 -->
                <div class="grid grid-cols-3 gap-4">
                    <div class="bg-white p-4 rounded-lg shadow-sm border border-slate-200">
                        <div class="text-slate-500 text-[10px] uppercase font-bold tracking-wider">已掃描頁面</div>
                        <div class="text-2xl font-bold text-slate-800" id="statScannedPages">0</div>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow-sm border border-slate-200">
                        <div class="text-slate-500 text-[10px] uppercase font-bold tracking-wider">找到字體數</div>
                        <div class="text-2xl font-bold text-indigo-600" id="statTotalFonts">0</div>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow-sm border border-slate-200">
                        <div class="text-slate-500 text-[10px] uppercase font-bold tracking-wider">內嵌風險</div>
                        <div class="text-2xl font-bold text-orange-500" id="statEmbeddedFonts">0</div>
                    </div>
                </div>

                <!-- 字體結果列表 -->
                <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden min-h-[300px]">
                    <div class="px-6 py-4 border-b border-slate-100 flex justify-between items-center bg-slate-50">
                        <h3 class="font-bold text-slate-800">
                            <i class="fa-solid fa-font mr-2 text-indigo-500"></i> 偵測結果匯總
                        </h3>
                        <div class="flex gap-2">
                             <div class="flex items-center gap-1 text-[10px] text-slate-500 mr-2">
                                <span class="w-2 h-2 rounded-full bg-green-500"></span> 連結
                                <span class="w-2 h-2 rounded-full bg-orange-500 ml-1"></span> 內嵌
                             </div>
                            <!-- 匯出 Excel 按鈕 -->
                            <button onclick="exportExcel()" class="text-xs bg-green-600 hover:bg-green-700 text-white border border-transparent px-3 py-1 rounded transition shadow-sm hover:shadow flex items-center gap-2">
                                <i class="fa-solid fa-file-excel"></i> 匯出 Excel (.xlsx)
                            </button>
                        </div>
                    </div>
                    
                    <div id="fontList" class="divide-y divide-slate-100">
                        <div class="p-8 text-center text-slate-400 text-sm">
                            尚未開始掃描，請輸入網址並點擊分析。
                        </div>
                    </div>
                </div>

            </div>
        </div>

    </main>

    <script>
        // --- 設定 ---
        const MAX_BATCH_SIZE = Infinity; // 無限制批次掃描

        // --- 狀態管理 ---
        let state = {
            rootUrl: '',              // 使用者輸入的起始網址
            queue: [],                // 等待掃描的網址隊列
            scannedUrls: new Set(),   // 已掃描過的網址
            foundFonts: new Map(),    // 偵測到的字體資訊
            isScanning: false         // 是否正在批次掃描
        };

        // --- UI 元素參考 ---
        const UI = {
            urlInput: document.getElementById('urlInput'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            mainInterface: document.getElementById('mainInterface'),
            urlList: document.getElementById('urlList'),
            fontList: document.getElementById('fontList'),
            miniLog: document.getElementById('miniLog'),
            queueCount: document.getElementById('queueCount'),
            batchActions: document.getElementById('batchActions'),
            batchBtn: document.getElementById('batchBtn'),
            stats: {
                pages: document.getElementById('statScannedPages'),
                fonts: document.getElementById('statTotalFonts'),
                embedded: document.getElementById('statEmbeddedFonts')
            }
        };

        // --- 核心邏輯 ---

        // 清除輸入框
        function clearInput() {
            UI.urlInput.value = '';
            UI.urlInput.focus();
        }

        // 日誌輸出
        function log(msg, type = 'info') {
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            if (type === 'error') div.style.color = '#f87171';
            UI.miniLog.appendChild(div);
            UI.miniLog.scrollTop = UI.miniLog.scrollHeight;
        }

        // 1. 開始分析流程
        async function startInitialScan() {
            let inputUrl = UI.urlInput.value.trim();
            if (!inputUrl) return alert('請輸入網址');
            
            // 自動補 https
            if (!/^https?:\/\//i.test(inputUrl)) {
                inputUrl = 'https://' + inputUrl;
                UI.urlInput.value = inputUrl;
            }

            // 重設狀態
            state = {
                rootUrl: inputUrl,
                queue: [],
                scannedUrls: new Set(),
                foundFonts: new Map(),
                isScanning: false
            };
            
            UI.fontList.innerHTML = '';
            UI.urlList.innerHTML = '';
            UI.miniLog.innerHTML = '';
            UI.mainInterface.classList.remove('hidden');
            UI.batchActions.classList.add('hidden');
            updateStats();

            // 將首頁加入隊列並開始分析
            addToQueue(inputUrl);
            await processQueueItem(0); 
        }

        // 2. 處理單一網址
        async function processQueueItem(index) {
            if (index >= state.queue.length) return;
            
            const item = state.queue[index];
            if (item.status !== 'pending') return;

            item.status = 'scanning';
            updateQueueUI();
            log(`正在分析: ${shortUrl(item.url)}`);

            try {
                // 透過代理抓取 HTML
                const htmlContent = await fetchViaProxy(item.url);
                if (!htmlContent) throw new Error('無法讀取內容，可能是防火牆或代理限制');

                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');

                // A. 解析字體
                await scanPageForFonts(doc, item.url);

                // B. 首頁自動發現同目錄頁面
                if (index === 0) {
                    extractInternalLinks(doc, item.url);
                }

                item.status = 'done';
                log(`分析完成: ${shortUrl(item.url)}`);

            } catch (e) {
                console.error(e);
                item.status = 'error';
                log(`錯誤: ${shortUrl(item.url)} - ${e.message}`, 'error');
            }

            updateQueueUI();
            updateResultsUI();
            updateStats();
        }

        // 3. 解析同目錄下的其他頁面連結
        function extractInternalLinks(doc, baseUrl) {
            const links = Array.from(doc.querySelectorAll('a[href]'));
            let baseObj;
            try { baseObj = new URL(baseUrl); } catch(e) { return; }
            
            let pathScope = baseObj.pathname; 
            // 只抓同目錄下的頁面
            if(pathScope.split('/').pop().includes('.')) {
                pathScope = pathScope.substring(0, pathScope.lastIndexOf('/') + 1);
            }

            let count = 0;
            links.forEach(a => {
                try {
                    const absoluteUrl = new URL(a.getAttribute('href'), baseUrl).href;
                    
                    if (absoluteUrl.startsWith(baseObj.origin + pathScope) && 
                        absoluteUrl !== baseUrl &&
                        !state.queue.some(q => q.url === absoluteUrl) &&
                        !absoluteUrl.includes('#')
                    ) {
                        // 過濾檔案類型
                        const ext = absoluteUrl.split('.').pop().toLowerCase();
                        if (['pdf', 'jpg', 'png', 'zip', 'rar', 'doc', 'docx'].includes(ext)) return;

                        addToQueue(absoluteUrl);
                        count++;
                    }
                } catch (e) {}
            });

            if (count > 0) {
                log(`發現 ${count} 個同目錄頁面`);
                UI.batchActions.classList.remove('hidden');
            }
        }

        // 4. 掃描單一頁面用到的字體
        async function scanPageForFonts(doc, pageUrl) {
            // 1. 解析內嵌 <style>
            const styleTags = Array.from(doc.querySelectorAll('style'));
            styleTags.forEach(style => parseCss(style.textContent, pageUrl, 'Inline Style'));

            // 2. 解析外部 CSS
            const linkTags = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
            for (const link of linkTags) {
                const href = link.getAttribute('href');
                if (href) {
                    let cssUrl;
                    try { cssUrl = new URL(href, pageUrl).href; } catch(e) { continue; }
                    
                    try {
                        log(`抓取 CSS: ${shortUrl(cssUrl)}`);
                        const cssContent = await fetchViaProxy(cssUrl);
                        if (cssContent) {
                            parseCss(cssContent, cssUrl, 'External CSS');
                        }
                    } catch (e) {
                        log(`CSS 讀取失敗: ${shortUrl(cssUrl)}`, 'error');
                    }
                }
            }
        }

        // 5. 批次掃描所有發現頁面
        async function startBatchScan() {
            if (state.isScanning) return;
            state.isScanning = true;
            UI.batchBtn.disabled = true;
            UI.batchBtn.innerHTML = '<span class="loader w-3 h-3 border-white border-t-transparent mr-2"></span> 掃描中...';

            let processCount = 0;
            for (let i = 1; i < state.queue.length; i++) {
                // 無限制掃描
                // if (processCount >= MAX_BATCH_SIZE) break; 
                
                if (state.queue[i].status === 'pending') {
                    await processQueueItem(i);
                    processCount++;
                    await new Promise(r => setTimeout(r, 800)); // 避免過快
                }
            }

            state.isScanning = false;
            UI.batchBtn.disabled = false;
            UI.batchBtn.innerHTML = '<i class="fa-solid fa-layer-group"></i> 掃描完成';
            log('所有頁面掃描完成');
        }

        // --- CSS 解析輔助 ---
        
        function parseCss(cssText, sourceUrl, type) {
            // 移除註解
            const cleanCss = cssText.replace(/\/\*[\s\S]*?\*\//g, '');
            const fontFaceRegex = /@font-face\s*{([^}]*)}/g;
            let match;

            while ((match = fontFaceRegex.exec(cleanCss)) !== null) {
                const content = match[1];
                
                // 解析 font-family
                const familyMatch = content.match(/font-family\s*:\s*['"]?([^;'"]+)['"]?/i);
                const fontFamily = familyMatch ? familyMatch[1].trim() : 'Unknown';

                // 解析 src: url(...)
                const urlRegex = /url\s*\(\s*(?:['"]?)(.*?)(?:['"]?)\s*\)/gi;
                let urlMatch;

                while ((urlMatch = urlRegex.exec(content)) !== null) {
                    let rawUrl = urlMatch[1];
                    let uniqueKey = '';
                    let fileType = '';
                    let fileName = '';
                    let embeddingMethod = 'external'; // 'external' or 'embedded'

                    if (rawUrl.startsWith('data:')) {
                        // 內嵌字體 (Base64)
                        embeddingMethod = 'embedded';
                        
                        if (rawUrl.includes('woff2')) fileType = 'woff2';
                        else if (rawUrl.includes('woff')) fileType = 'woff';
                        else if (rawUrl.includes('ttf')) fileType = 'ttf';
                        else if (rawUrl.includes('otf')) fileType = 'otf';
                        else if (rawUrl.includes('eot')) fileType = 'eot';
                        else if (rawUrl.includes('svg')) fileType = 'svg';
                        else continue; 

                        uniqueKey = rawUrl.substring(0, 100) + rawUrl.length;
                        fileName = `內嵌字體 (Base64) - ${fileType.toUpperCase()}`;
                    
                    } else {
                        // 外部字體連結
                        embeddingMethod = 'external';
                        fileType = getFileType(rawUrl);
                        
                        if (!['woff2', 'woff', 'ttf', 'otf', 'eot', 'svg'].includes(fileType)) continue;

                        try { 
                            uniqueKey = new URL(rawUrl, sourceUrl).href; 
                        } catch(e) { continue; }
                        
                        fileName = rawUrl.split('/').pop().split('?')[0];
                    }

                    // 加入 state.foundFonts
                    if (uniqueKey) {
                        if (!state.foundFonts.has(uniqueKey)) {
                            state.foundFonts.set(uniqueKey, {
                                family: fontFamily,
                                url: rawUrl, 
                                fullUrl: embeddingMethod === 'external' ? uniqueKey : 'Base64 Data',
                                type: fileType,
                                fileName: fileName,
                                method: embeddingMethod,
                                foundOn: [sourceUrl] 
                            });
                        } else {
                             const existing = state.foundFonts.get(uniqueKey);
                             if (!existing.foundOn.includes(sourceUrl)) {
                                 existing.foundOn.push(sourceUrl);
                             }
                        }
                    }
                }
            }
        }

        // --- 工具函式 ---

        // 加入掃描隊列
        function addToQueue(url) {
            state.queue.push({
                url: url,
                status: 'pending'
            });
            updateQueueUI();
        }

        // 透過 CORS 代理抓取內容
        async function fetchViaProxy(targetUrl) {
            const proxies = [
                {
                    name: 'AllOrigins',
                    url: (u) => `https://api.allorigins.win/get?url=${encodeURIComponent(u)}&disableCache=true`,
                    extract: async (res) => {
                        const data = await res.json();
                        if (!data.contents) throw new Error('Empty content');
                        return data.contents;
                    }
                },
                {
                    name: 'CodeTabs',
                    url: (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
                    extract: async (res) => {
                        const text = await res.text();
                        if (!text || text.trim().length === 0) throw new Error('Empty text');
                        return text;
                    }
                }
            ];

            for (const proxy of proxies) {
                try {
                    const res = await fetch(proxy.url(targetUrl));
                    if (!res.ok) throw new Error(`Status ${res.status}`);
                    const content = await proxy.extract(res);
                    return content;
                } catch (e) { continue; }
            }
            return null; 
        }

        // 取得檔案副檔名
        function getFileType(url) {
            try {
                return url.split('?')[0].split('#')[0].split('.').pop().toLowerCase();
            } catch(e) { return ''; }
        }

        // 簡化網址顯示
        function shortUrl(url) {
            try {
                const u = new URL(url);
                const parts = u.pathname.split('/').filter(p => p);
                return parts.length > 0 ? parts[parts.length-1] : u.hostname;
            } catch(e) { return '...'; }
        }

        // --- UI 更新 ---

        // 更新掃描隊列 UI
        function updateQueueUI() {
            UI.queueCount.innerText = state.queue.length;
            UI.urlList.innerHTML = '';
            
            state.queue.forEach((item, index) => {
                const div = document.createElement('div');
                let icon = 'fa-circle-notch';
                let statusClass = 'scan-status-pending';
                
                if (item.status === 'scanning') { icon = 'fa-spinner fa-spin'; statusClass = 'scan-status-loading'; }
                else if (item.status === 'done') { icon = 'fa-check'; statusClass = 'scan-status-done'; }
                else if (item.status === 'error') { icon = 'fa-xmark'; statusClass = 'scan-status-error'; }

                div.className = `flex items-center gap-2 p-2 rounded hover:bg-slate-100 ${statusClass}`;
                div.innerHTML = `
                    <i class="fa-solid ${icon} w-4 text-center"></i>
                    <span class="truncate text-[11px] flex-grow" title="${item.url}">${shortUrl(item.url)}</span>
                `;
                UI.urlList.appendChild(div);
            });
        }

        // 更新字體結果 UI
        function updateResultsUI() {
            const fonts = Array.from(state.foundFonts.values());
            
            if (fonts.length === 0) {
                UI.fontList.innerHTML = `<div class="p-8 text-center text-slate-400 text-sm">目前尚未偵測到字體檔案。<br><span class="text-xs text-slate-300">如果網站使用系統字體，則不會顯示在此。</span></div>`;
                return;
            }

            UI.fontList.innerHTML = '';
            fonts.forEach(font => {
                const isEmbedded = font.method === 'embedded';
                const badgeClass = isEmbedded 
                    ? 'bg-orange-100 text-orange-600 border-orange-200' 
                    : 'bg-green-50 text-green-600 border-green-200';
                const badgeText = isEmbedded ? '<i class="fa-solid fa-file-code mr-1"></i> 內嵌編碼' : '<i class="fa-solid fa-link mr-1"></i> 外部連結';
                const dlBtn = isEmbedded ? '' : `
                    <a href="${font.fullUrl}" target="_blank" class="shrink-0 text-xs bg-white border border-slate-200 hover:border-indigo-300 text-indigo-600 w-8 h-8 flex items-center justify-center rounded-full transition">
                        <i class="fa-solid fa-download"></i>
                    </a>`;

                // 多來源顯示
                const sourceCount = font.foundOn.length;
                const sourceText = sourceCount > 1 
                    ? `來源: ${shortUrl(font.foundOn[0])} ... (+${sourceCount-1} 其他頁面)`
                    : `來源: ${shortUrl(font.foundOn[0])}`;
                
                const el = document.createElement('div');
                el.className = `p-4 hover:bg-indigo-50 transition group border-l-4 ${isEmbedded ? 'border-orange-400' : 'border-green-400'}`;
                el.innerHTML = `
                    <div class="flex justify-between items-start gap-4">
                        <div class="flex-grow min-w-0">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-[10px] font-bold px-2 py-0.5 rounded border ${badgeClass}">${badgeText}</span>
                                <span class="bg-slate-200 text-slate-700 text-[10px] font-bold px-2 py-0.5 rounded uppercase">${font.type}</span>
                            </div>
                            <h4 class="font-bold text-slate-800 truncate text-base mb-1">${font.family}</h4>
                            <div class="text-xs text-slate-500 font-mono truncate mb-1">
                                <i class="fa-regular fa-file mr-1"></i> ${font.fileName}
                            </div>
                            <div class="text-[10px] text-slate-400 truncate cursor-help" title="發現於:\n${font.foundOn.join('\n')}">
                                ${sourceText}
                            </div>
                        </div>
                        ${dlBtn}
                    </div>
                    <div class="mt-2 text-[10px] text-slate-400 font-mono break-all bg-white p-2 rounded border border-slate-100 hidden group-hover:block select-all max-h-20 overflow-hidden">
                        ${isEmbedded ? '(Base64 數據過長，不在此完整顯示)' : font.fullUrl}
                    </div>
                `;
                UI.fontList.appendChild(el);
            });
        }

        // 更新統計數據
        function updateStats() {
            const scanned = state.queue.filter(i => i.status === 'done').length;
            UI.stats.pages.innerText = scanned;
            UI.stats.fonts.innerText = state.foundFonts.size;
            
            const embeddedCount = Array.from(state.foundFonts.values()).filter(f => f.method === 'embedded').length;
            UI.stats.embedded.innerText = embeddedCount;
        }

        // --- 匯出 Excel ---
        function exportExcel() {
            const fonts = Array.from(state.foundFonts.values());
            if (fonts.length === 0) return alert('無資料可匯出');
            
            // 1. 標題與資料
            const header = ["字體名稱", "類型", "檔案名稱", "內嵌模式", "來源頁面", "完整連結"];
            const data = fonts.map(f => [
                f.family,
                f.type.toUpperCase(),
                f.fileName,
                f.method === 'embedded' ? '內嵌 (Embedded)' : '外部 (External)',
                f.foundOn.join('\n'), // Excel 換行
                f.fullUrl
            ]);

            // 2. 建立工作表
            const ws = XLSX.utils.aoa_to_sheet([header, ...data]);

            // 3. 樣式設定
            const borderStyle = {
                top: { style: "thin", color: { auto: 1 } },
                bottom: { style: "thin", color: { auto: 1 } },
                left: { style: "thin", color: { auto: 1 } },
                right: { style: "thin", color: { auto: 1 } }
            };

            const headerStyle = {
                fill: { fgColor: { rgb: "2563EB" } }, // 藍底
                font: { color: { rgb: "FFFFFF" }, bold: true, name: "Arial" }, // 白字
                alignment: { horizontal: "center", vertical: "center" },
                border: borderStyle
            };

            const cellStyle = {
                font: { name: "Arial" },
                alignment: { vertical: "top", wrapText: true }, // 自動換行
                border: borderStyle
            };

            // 4. 套用樣式
            if (ws['!ref']) {
                const range = XLSX.utils.decode_range(ws['!ref']);
                
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cell_address = { c: C, r: R };
                        const cell_ref = XLSX.utils.encode_cell(cell_address);
                        
                        // 若 cell 不存在，建立空 cell
                        if (!ws[cell_ref]) ws[cell_ref] = { t: 's', v: '' };
                        
                        if (R === 0) {
                            // 標題列
                            ws[cell_ref].s = headerStyle;
                        } else {
                            // 資料列
                            ws[cell_ref].s = cellStyle;
                        }
                    }
                }
            }

            // 5. 欄寬
            ws['!cols'] = [
                { wch: 25 }, // Family
                { wch: 10 }, // Type
                { wch: 30 }, // Filename
                { wch: 20 }, // Method
                { wch: 60 }, // Sources
                { wch: 50 }  // URL
            ];

            // 6. 產生 Excel 檔案
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Fonts Report");
            
            const dateStr = new Date().toISOString().slice(0,10);
            XLSX.writeFile(wb, `font_report_${dateStr}.xlsx`);
        }

    </script>
</body>
</html>